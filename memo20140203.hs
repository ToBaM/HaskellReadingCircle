-- オリエンテーション
-- ------------------

-- これはコメント!!!

-- 基本的に毎週月曜に20時から1時間
	-- 祝日の場合はおやすみ

-- 担当者は立候補で
	-- 範囲は終ったら発表します
	-- 翌々週まで発表者を決めます(準備がよくできるから)
	-- みんなの前でサンプルコードを実行してください

-- 仕事に影響ないように
	-- がんばらない
	-- 長く細く
	-- でも予習はちょっぴりがんばってね

-- 本の中で閉じる
	-- トリッキーなことはしない
	-- 突然でてきた言葉はぐぐってきてもいい

-- このファイルはcodebreak;にあげてあります
-- https://codebreak.com/git/konnyakmannan/HaskellReadingCircle/
-- このリポジトリで欠席分のフォローをします
	-- できたら私以外にもリポジトリの更新をお願いしたい
	-- コミット制限があるので登録します

-- ------------------
-- イントロダクション
-- ------------------

-- Haskellの特徴

-- 純粋関数型 <=> 命令型，手続き型
	-- 関数!!!
	-- 値を変更できない

-- 副作用がない
	-- 副作用：値を返すだけ，何にもしない

-- 遅延評価

-- 静的型付け

-- ---------------------
-- 第一章 はじめの第一歩
-- ---------------------

-- 演算の優先順位

(50 * 100) - 4999
50 * 100 - 4999
50 * (100 - 4999)

-- ブール代数

True && False
True && True
False || True
not False
not (True && True)

-- 等価判定

5 == 5
1 == 0
5 /= 5
5 /= 4
"hello" == "hello"
-- これはエラー
5 == "llama"
-- 整数と浮動小数は比較できる
5 == 4.0
-- 足し算もできる
5 + 4.0

-- ---------------------
-- 関数呼び出し
-- ---------------------
-- '*'も関数→中置関数
-- 前置関数

-- 簡単な関数
-- かっこをつけない
succ 8

-- 最大・最小
min 9 10
min 3.4 3.2
max 100 101

-- 関数の優先順位は最も高い
succ 9 + max 5 4 + 1
(succ 9) + (max 5 4) + 1 -- 上と同じ

-- 注意
succ 9 * 10
succ (9 * 10)

-- 前置を中置に
div 92 10
92 `div` 10 -- バッククォート

-- ---------------------
-- 赤ちゃんの最初の関数
-- ---------------------
-- 関数の定義
doubleMe x = x + x
doubleMe 9
doubleMe 8.3

-- 二つの引数
doubleUS x y = x * 2 + y * 2
doubleUS 4 9
doubleUS 2.3 34.2

-- 組合せ
doubleUS 28 88 + doubleMe 123

-- doubleMeを使って
doubleUS x y = doubleMe x + doubleMe y
doubleUS 4 9
doubleUS 2.3 34.2
doubleUS 28 88 + doubleMe 123

-- if'式'
-- 文ではない
-- かならず値を返すelse
doubleSmallNumber x = if x > 100 then x else x * 2
doubleSmallNumber 2
doubleSmallNumber 150

-- アポストロフィー
-- 正格評価(遅延評価でない)
-- あるいは少し変更したバージョン
doubleSmallNumber' x = (if x > 100 then x else x * 2) + 1
doubleSmallNumber' 2
doubleSmallNumber' 150

conanO'Brien = "It's a-me, Conan O'Brien!"
conanO'Brien
-- Haskellは関数を大文字ではじめない
-- 本文'…互いに交換できます．'→'どっちも同じものを指している'

-- ----------
-- リスト入門
-- ----------

-- リストは"同じ型"の要素を格納できる
lostNumbers = [4, 8, 15, 16, 23, 42]
lostNumbers

-- 連結ができる
[1, 2, 3, 4] ++ [9, 10, 11, 12]

-- 文字列は文字のリスト
"hello" ++ " " ++ "world"
["w", "o"] ++ ["o", "t"] -- ダブルクォートだと文字列のリストが返る
['w', 'o'] ++ ['o', 't']

-- 大きい文字列の連結は注意

-- cons
-- 先頭に要素を付け加える
'A':" SMALL CAT"
5:[1, 2, 3, 4, 5]
5 : [1, 2, 3, 4, 5] -- コロンの前後に空白入れてもいける

'A' : [1, 2, 3, 4, 5] -- ERROR 型をそろえる

-- ++演算子はリストどうしでなければならない
[1, 2, 3, 4] ++ [5]
[1, 2, 3, 4] ++ 5 -- ERROR

-- シンタックス・シュガー
-- [1, 2, 3] は 1 : 2 : 3 : [] と同じ

-- 要素をとりだす
"Steve Buscemi" !! 6
[9.4, 33.2, 96.2, 11.2, 23.25] !! 1

-- リストのリスト
b = [[1, 2, 3, 4], [5, 3, 3, 3], [1, 2, 2, 3, 4], [1, 2, 3]]
b
b ++ [[1, 1, 1, 1]] -- リストのリストでないといけない
[6, 6, 6] : b
b !! 2

c = [[[1, 2, 3]]]
c ++ [[[4, 5, 6]]]
-- リストの比較
-- 一番最初に見つかる違う要素を比較
[3, 2, 1] > [2, 1, 0]
[3, 2, 1] > [2, 10, 100]
[3, 4, 2] < [3, 4, 3]
[3, 4, 2] > [2, 4]
[3, 4, -1] < [3, 4]
[3, 4, 2] == [3, 4, 2]

[3, 2, 1] > [4, 1, 0]
[3, 1, 1] == [3, 4, 2]

-- head
-- 先頭の要素を返す
head [5, 4, 3, 2, 1]

-- tail
-- 先頭以外の要素の"リスト"
tail [5, 4, 3, 2, 1]

-- last
-- 最後の要素
last [5, 4, 3, 2, 1]

-- init
-- 最後以外の要素の"リスト"
init [5, 4, 3, 2, 1]

-- 空のリストに対してはエラー
head []
tail []
last []
init []

-- lenght
length [5, 4, 3, 2, 1]
length [[1, 2, 3], [2, 3]]

-- null
-- 空リストかどうか
null [] -- True
null [1, 2, 3] -- False

-- reverse
reverse [5, 4, 3, 2, 1]

-- take
-- 先頭からn個の要素のリスト
take 3 [5, 4, 3, 2, 1]
take 1 [3, 9, 3]
take 5 [1, 2]
take 0 [6, 6, 6]

-- drop
-- 先頭からn個を削除した要素のリスト
drop 2 [8, 4, 2, 1, 5, 6]
drop 0 [1, 2, 3, 4]
drop 100 [1, 2, 3, 4]

-- maximum, minimum
maximum [1, 9, 2, 3, 4]
minimum [8 ,4, 2, 1, 5, 6]

-- sum
sum [5, 2, 1, 6, 3, 2, 5, 7]
product [6, 2, 1, 2]
product [1, 2, 5, 6, 7, 9, 2, 0]

-- elem
-- リストの要素に含まれているか，判定する
4 `elem` [3, 4, 5, 6]
10 `elem` [3, 4, 5, 6]

-- ----------
-- レンジでチン!
-- ----------

-- 1から20までを列挙する
[1..20]

-- 文字も
['a'..'z']
['K'..'Z']

-- 13の倍数の最初の23個
[13, 26..24*13]

-- 無限のリストを使う
take 24 [13, 26..]
take 24 [13, 2*13..]

[2, 4..63]
[20, 19..1]

-- 無限のリストを作る関数

-- cycle
take 10 (cycle [1, 2, 3])

-- repeat
take 10 (repeat 5)
take 10 (repeat [1, 2])

-- replicate
replicate 3 10
replicate 3 [1, 2]

-- 浮動小数は微妙
[0.1, 0.3..1.0]